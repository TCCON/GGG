      subroutine spectrum_loop(ap_file,winfo,lun_col,
     & runlog,akfile,rayfile,mavfile,targmol,linefiles,
     & parfile,dplist,ntg,speci,nspexi,solarll,pars,sptfile)
c
c   Inputs:
c     nmp           I*4  Number of measured points (in spectrum)
c     nfp           I*4  number of fitted parameters (in state vector)
c     obsrvd(nmp)   R*4  Measured spectrum (y)
c     apx(nfp)      R*4  A priori state vector (xa)
c     apu(nfp)      R*4  A priori state vector uncertainties (Sa)
c
c   Outputs:
c     calcul(nmp)   R*4  Calculated spectrum (f(x))
c     cx(nfp)       R*4  State vector (x)
c     ex(nfp)       R*4  State vector uncertainties
c     sgshift       R*4  Solar-Gas Shift (ppm)

c  mode=0    Checks that all input files are readable before investing
c            a lot of time on doing the VAC calculation.
c  mode=1    Does full calculation

      implicit none

      logical
     & debug

      integer*4 lf,fbc,
     & ncall,           ! counts the number of times that subroutine is called
     & lcolon,
     & totit,nn,ncol,nspectra,mspectra,
     & n1,n2,n3,n4,
     & mcp,ncp,
     & mva,nva,         ! The number of precomputed anscoption coefficients
     & mvmr,
     & istat,ifm,
     & nscycle,
     & mspt,ispec,
     & freq_flag,       ! =1  presents spectral fits in solar rest frame. 
                        ! =0  presents spectral fits in atmosphere rest frame.
     & lun_ak,
     & lun_sts,         ! Solar Transmittance Spectrum
     & lun_apx,         ! A priori state vector file
     & lnbc,
     & nspexi,jspeci,
     & mmp,nmp,imp,
     & nhw,ldec,nmpfp,
     & mii, nii,            ! Dimension of interpolated (by factor LDEC) ILS
     & mtg,ntg,jtg,
     & mfp,nfp,
     & jsp,jva,
     & lc,lr,
     & interp,
     & defapo,apo_c,apo_m,rc,j,
     & mspxv,
     & mslpd,
     & iseed,
     & mlev,nlev,ilev,
     & mit,nit,
     & iyr,iset,
     & kspflag,ifirst,ilast,bytepw,possp,
     & kcp1,kcp2,
     & nsh,nhwmax,
     & lun_col,lun_spt,lun_mav,lun_ray,lun_rlg,mavfound

      parameter (mmp=360000,mva=125000000,mcp=1240000,
     & nscycle=25,
     & mvmr=28000,mtg=15,mfp=mtg+4,mii=103847,mlev=200,
     & mslpd=10*mmp*mtg,mspxv=5*mcp)

      parameter (lun_apx=23,lun_sts=24,lun_rlg=25,lun_ak=26,
     & lun_ray=27,lun_mav=28,lun_spt=29)

      integer*4
     & speci(mtg),
     & targmol(nspexi)

      real*4
     & vac(mva),
     & ssnmp(mmp),
     & slit(mii),cx(ntg+4),ex(ntg+4),
     & obsrvd(mmp),calcul(mmp),
     & overcol(mtg),oloscol(mtg),
     & zmin,zminwas,
     & ckm2cm,
     & gasdev,  ! random number generator
     & apx(ntg+4),apu(ntg+4),
     & rms, 
     & dd,
     & sza_ray,sza_raywas,bend,
     & tprange,zfov,
     & tot,pi,
     & vmr(mvmr),
     & vpf(mvmr),
     & spver(mlev),splos(mlev),dspdz(mlev),dsplo,dsphi,cp(mlev),
     & z(mlev),t(mlev),p(mlev),d(mlev),
     & corrld,           ! Factor=[apodixed resolution]/[spectral point spacing
     & solar_gas_shift,sgshift,
     & zero,unity,fovcf,
     & slpd(mslpd),
     & pd((mmp+mfp)*mfp), spts(mcp),
     & spxv(mspxv),
     & dspdzxv(mspxv),
     & solzen,roc,fbar,
     & rdum

      real*8
     & riair,
     & tottc,tottc2,toterr,avgtc,rmstc,avgcl,avgrms,
     & sssss,
     & eorv,             ! Earth-Object Radial Velocity (m/s)
     & ervc,             ! Earth Rotational Velocity Component (m/s)
     & frac,             ! fractional size of FOVO compared with solar diameter
     & dopp,             ! Earth-SUN Doppler stretch.
     & resn,             ! 0.5d0/opd = half width of SINC function in cm-1
     & resmax,           ! maximum value of resn
     & rect,             ! frqcen*(fovi**2+amal**2)/8 = width of rectangle(cm-1)
     & resnog,           ! RESN / GRID = 0.5/(OPD*grid)
     & rectog,           ! RECT / GRID
     & rdec,             ! Ratio: GINT/GRID = spectral/primitive point spacings
     & frqcen,           ! centRal frequency (cm-1) of spectral window
     & width,            ! width (cm-1) of spectral window
     & fzero,            ! frequency of the zero'th computed VAC
     & startm,           ! frequency of first returned measured point
     & nus,              ! microwindow starting frequency (cm-1)
     & nue,              ! microwindow ending frequency (cm-1)
     & graw,             ! spacing of raw spectrum (cm-1) from GETINFO
     & gint,             ! spacing of OBSRVD (cm-1) after interpolation
     & grid,             ! spacing of primitive spectrum 
     & vbar,             ! mean frequency of measured spectrum
     & hwid              ! half-width of measured spectrum

      real*8 
     & oblat,            ! observation latitude (deg).
     & oblon,            ! observation longitude (deg).
     & obalt,            ! observation altitude (km)
     & zpdtim,           ! Time of ZPD (UT hours)
     & asza,             ! astronomical solar zenith angle (unrefracted)
     & zenoff,           ! zenith pointing offset
     & fovi,             ! Internal angular diameter of FOV (radians)
     & fovo,             ! External angular diameter of FOV (radians)
     & amal,             ! angular misalignment of interferometer (radians)
     & zoff,             ! zero-level offset
     & snr,              ! Signal-to-Noise Ratio
     & tins,             ! Temperature INSide the instrument
     & pins,             ! Pressure INSide the instrument
     & hins,             ! Humidity INSide the instrument
     & tout,             ! Temperature OUTside the instrument
     & pout,             ! Pressure OUTside the instrument
     & hout,             ! Humidity OUTside the instrument
     & sia,              ! Solar Intensity (Average)
     & sis,              ! Solar Intensity (SD)
     & aipl,             ! Airmass-Independent Path Length (km)
     & lasf,             ! laser frequency (e.g. 15798.03 cm-1)
     & wavtkr,           ! suntracker operating frequency (e.g. 9900 cm-1)
     & opd,              ! Optical path difference (cm) of interferogram
     & ddum

      character winfo*(*),ap_file*(*),runlab*35,pars(ntg)*(*),
     & sptfile*(*),akpath*128,akfile*(*),specpath*128,sptpath*128,
     & solarll*(*),runlabmav*35,oformat*10,colabel*600,
     & mavstring*35,linefiles*(*),parfile*(*),dplist*(*),
     & col1*1,apf*2,rayfile*(*),specray*35,runlog*(*),mavfile*(*),
     & string*48

      parameter (zero=0.0,unity=1.0,ckm2cm=1.0E+05,pi=3.14159265,
     & mspectra=999999)
c
      save ispec,resmax,ncall
      data ispec/0/
      data ncall/0/
      data resmax/0.0/

      n1=ntg+1
      n2=ntg+2
      n3=ntg+3
      n4=ntg+4
      nfp=ntg+4

c  Read max # of SPT files (if a value is provided on the SPT line of the .ggg file)
      mspt=2000  ! default value
      lf=fbc(sptfile)
      if(lnbc(sptfile).gt.lf) read(sptfile(lf:),*) mspt

      if( index(winfo,'debug') .gt. 0 ) then
         debug=.true.
      else
         debug=.false.
      endif

      if (debug) write(*,*) 'Entered spectrum_loop: ncall=',ncall

      open(lun_mav,file=mavfile,status='old')
      read(lun_mav,*)
      read(lun_mav,'(14x,a)')string
      lcolon=index(string,':')
      read(string(lcolon+1:),'(a)')runlabmav

      open(lun_ray,file=rayfile,status='old')
      read(lun_ray,*)nn,ncol
      call skiprec(lun_ray,nn-1)
      nlev=ncol-7  ! First 7 columns are (spec,Zobs,Pobs,SZA,Bend,FOV,Zmin)
c
      if(nlev.gt.mlev) then
         write(*,*) 'nlev,mlev=',nlev,mlev
         stop 'Increase parameter MLEV'
      endif
 
      if(nlev*nspexi.gt.mvmr) then
         write(*,*)'nlev*nspexi,mvmr=',nlev*nspexi,mvmr
         stop ' spectrum_loop: Increase parameter mvmr'
      endif
c
      read(winfo,*) frqcen,width,mit,defapo,interp,freq_flag
      grid=0.666666d-06*frqcen
      nus=frqcen-width/2
      nue=frqcen+width/2
12    kcp1=int(nus/grid)
      kcp2=int(nue/grid)
      nsh=int(2+2*resmax/grid)
      nhwmax=nint(nscycle*resmax/grid)
      ncp=kcp2-kcp1+2*nhwmax+2*nsh
      fzero=grid*(kcp1-nsh-nhwmax)
      nva=ncp*nlev*(ntg+1)
      if(nva+ncp.gt.mva) then
        write(6,*)'Increase MVA from',mva,' to',nva+ncp
        write(6,*)'to avoid loss of accuracy'
        grid=1.0022d0*grid*(nva+ncp)/mva
        go to 12
      endif

      if(ncp.gt.mcp) then
        write(*,*) 'MCP, NCP=',mcp,ncp
        stop 'Increase parameter MCP'
      endif

      if(nfp*ncp.gt.mspxv) then
         write(6,*)' Increase MSPXV=',mspxv,' to ',ncp*nfp
         stop 'next_spectrum: Increase parameter MSPXV'
      endif
C
      avgrms=0.0d0
      tottc=0.0d0
      tottc2=0.0d0
      toterr=0.0d0
      avgcl=0.0d0
      totit=0
      mavfound=0
      open(lun_rlg,file=runlog,status='unknown')
      read(lun_rlg,*)
      if(debug) write(*,*)' Main loop...',nspectra
      do ispec=1,mspectra         !  Main fitting loop over spectra
141     call read_runlog(lun_rlg,col1,runlab,iyr,iset,zpdtim,
     &  oblat,oblon,obalt,asza,zenoff,opd,fovi,fovo,amal,ifirst,
     &  ilast,graw,possp,bytepw,zoff,snr,apf,tins,pins,hins,
     &  tout,pout,hout,lasf,wavtkr,sia,sis,aipl,istat)
        if(debug) write(*,*) runlab, istat
        if(istat.ne.0) go to 89
c           if(ncall.le.0) go to 89
c           write(*,*)'ispec,istat,runlab=',ispec,istat,runlab
c            stop 'error in read_runlog'
c        endif  ! istat.ne.0

        lr=lnbc(runlab)
        runlab=runlab(:lr)
c
        read(lun_ray,*)specray,rdum,rdum,sza_ray,bend,rdum,zmin,
     &  (splos(j),j=1,nlev)
c        write(37,*)zmin,zminwas,sza_ray,sza_raywas,
c     &  (zmin-zminwas)/(sza_ray-sza_raywas)
        zminwas=zmin
        sza_raywas=sza_ray
        specray=specray(:lr)
        if(specray.ne.runlab) then
          write(6,*) specray,runlab
          stop 'spectrum mismatch 2'
        endif
c
c  Apply air-to-vacuum  & FOV corrections
        if(kspflag.lt.2) graw=graw*riair(lasf,tins,pins,hins)/
     &  riair(frqcen,tins,pins,hins)
c        graw=graw*(1.D0+(amal**2+fovi**2)/16)  ! FOV correction

c  If MIT > 0, check that requested spectrum is on disk,
c  and that it covers the specified spectral interval.
        kspflag=0
        call gindfile(dplist,runlab,specpath)
c        write(*,*)runlab,specpath
        if(lnbc(specpath).eq.0) kspflag=2
        resn=0.5d0/opd
        if(resn.gt.resmax) resmax=resn
c        if(resn.lt.graw) resn=graw
c  Measured spectrum must be wider than fitting interval to
c  allow convolution with apodizing/interpolating ILS
        dd=nscycle*resn ! half-width of the slit function in cm-1 (always +ve)
        vbar=0.5d0*graw*(ilast+ifirst)
        hwid=0.5d0*dabs(graw*(ilast-ifirst))
c        write(*,*)ilast,ifirst,vbar,hwid,dd
        if(kspflag.eq.2) dd=0.0
        if(debug)write(*,*)kspflag,nus,nue,vbar,hwid,vbar-hwid,vbar+hwid
        if( nus-dd .lt. vbar-hwid ) kspflag=1   ! Lower window limit < disk file
        if( nue+dd .gt. vbar+hwid ) kspflag=1   ! Upper window limit > disk file
c        if(nint((nus-dd)/graw).lt.ifirst .or.
c     &  nint((nue+dd)/graw).gt.ilast) kspflag=1
c========================================================================
c  Read model & vmr information (SUNRUN.MAV)
c      write(*,*)'runlab, runlabmav=',runlab, runlabmav
      lr=lnbc(runlab)
      if(ncall.ge.1) then
      if(runlab.eq.runlabmav) then
         call read_mav(lun_mav,mlev,nlev,nspexi,z,t,p,d,vmr)
         read(lun_mav,'(a)',end=66) mavstring
         if(mavstring(1:14).eq.'Next Spectrum:') then
            read(mavstring(15:),'(a)') runlabmav
         else
            write(*,*) mavstring
            write(*,*)'Failed to find Next Spectrum string'
            stop
         endif
66       continue
         if(index(winfo,' sa_temp ').gt.0) call vadd(t,1,5.,0,t,1,nlev) 
         if(index(winfo,' sa_pres ').gt.0) call vmul(p,1,.95,0,p,1,nlev)
c
c  Pre-compute absorption coefficient
c         nva=ncp*nlev*(ntg+1)
         call vmov(zero,0,vac,1,nva)
c         write(*,*)' Calling abscoi...'
         call abscoi(nlev,t,p,d,nspexi,targmol,vmr,vpf,
     &   linefiles,parfile,fzero,grid,ncp,vac,vac(nva+1))
c         write(*,*)' Called abscoi...'
         write(oformat,'(a5,i2.2,a3)')'(1x,a',lr+1,',a)'
c         write(6,'(1x,a21,a)')runlab(:lr+1),
         write(6,oformat)' Spectrum            ',
     &   'Nit  CL   CT   FS   S-G  ZO   RMS/CL'//
     &   '   Zpres   AM      OVC        VSF   VSF_err'
         if(mavfound.eq.0) then
            colabel='Nit  CL   CT   FS  S-G  ZO    RMS/CL   Zpres'
            do jtg=1,ntg
               if(speci(jtg).eq.0) then
                  write(*,*) jtg,pars(jtg),'unrecognized or duplicated'
                  stop
               else
                  lc=lnbc(colabel)
                  colabel=colabel(:lc)//'  AM_'//pars(jtg)(:6)
     &            //' OVC_'//pars(jtg)(:6)//' VSF_'//pars(jtg)(:6)
     &            //' VSF_'//pars(jtg)(:lnbc(pars(jtg)))//'_error'
               endif
            end do
            write(lun_col,oformat)' Spectrum            ',
     &      colabel(:lnbc(colabel))
         endif  !  mavfound.eq.0
         mavfound=mavfound+1
      else
         if(mavfound .eq. 0) then
            write(*,*) 'Mavfile data-block is missing: '
            write(*,*) 'Current Spectrum:',runlab
            write(*,*) 'Current Mavfile:',runlabmav
            stop
         endif
      endif          ! (runlab.eq.runlabmav)
      endif          ! (ncall.ge.1) then
      if(debug) write(*,*)'mit, kspflag=',mit, kspflag
      if(mit.gt.0 .and. kspflag.gt.0) goto 141 ! skip missing/partial spectrum
      if(mit.eq.0 .and. kspflag.eq.1) goto 141 ! skip missing/partial spectrum
c=========================================================
      resn=0.5d0/opd
c      if(resn.lt.graw) resn=graw
      if(index(winfo,' sa_fovi ').gt.0) fovi=fovi*1.97
      rect=frqcen*(fovi**2+amal**2)/8  ! old code
      if(ncall.ge.1) then
c
c  This code from DG is a crude attempt to simulate
c  a frequency-independent misalignment effect.
c      if(runlog(ir+1:ir+2).eq.'in') then
c         rect=frqcen*(fovi**2)/8 + 2100.D0*(amal**2)/8
c      elseif(runlog(ir+1:ir+2).eq.'hg') then
c         rect=frqcen*(fovi**2)/8 + 800.D0*(amal**2)/8
c      else
c         rect=frqcen*(fovi**2+amal**2)/8
c      endif
c
c  Select apodization function
        if(apf.eq.'BX') then
           apo_m=defapo
           apo_c=defapo
        else  ! if the measured spectra are already apodized
           apo_m=0  ! for perfect representation of synthetic spectra
           if(apf.eq.'N1') then
             apo_c=1
           elseif(apf.eq.'N2') then
             apo_c=2
           elseif(apf.eq.'N3') then
             apo_c=3
           elseif(apf.eq.'TR') then
             apo_c=4
           else 
             write(6,'(a21,1x,a2,1x,a)')
     &       runlab,apf,' ???  Unknown apodization function'
             stop
           endif
        endif

c---------------------------------------------------------
c  FIND the spectral file, return the PATH to the spectrum
      call vmov(zero,0,obsrvd,1,mmp)
      if(kspflag.eq.0) then
        call jetspe(specpath,opd,graw,ifirst,ilast,possp,bytepw,nus,
     &  nue,apo_m,interp,zero,zero,
     &  obsrvd,mmp,nmp,startm,gint,rc)
        if(rc.ne.0) then
           write(6,*)' Error in JETSPE. Spectrum ',runlab,rc,nmp
           write(6,*)' This error should never happen'
           kspflag=1
        endif
      endif
      if(kspflag.eq.2) then
         startm=nus
         gint=graw/interp
         nmp=1+(nue-nus)/gint
      endif
      if(nmp.gt.mmp) then
        write(*,*)'nmp,mmp=',nmp,mmp
        stop 'Increase parameter MMP'
      endif

      if(index(winfo,' sa_snr ').gt.0) then  ! Add noise
c  Add noise and systematic error to OBSRVD (assumes a continuum level of 1.0)
      do imp=1,nmp
      obsrvd(imp)=obsrvd(imp)+0.0001*gasdev(iseed)*opd ! add 0.25% rms random noise
c      obsrvd(imp)=obsrvd(imp)*(1+0.01*4*imp*(nmp-imp)/nmp/nmp)  ! add +- 1% Cont Curv
c      obsrvd(imp)=obsrvd(imp)*(1+0.005*obsrvd(imp))  !  0.5%  detector non-linearity
      end do
      endif
      iseed=iseed+1113

      nmpfp=nmp+nfp
c  Pre-compute ILS (oversampled by a factor LDEC) and normalize each
c  interleaved component to unity.
      rdec=gint/grid
      nhw=nint(nscycle*resn/grid)
      ldec=1+int(16*grid/resn)
      nii=1+2*nhw*ldec
      resnog=ldec*resn/grid
      rectog=ldec*rect/grid
      call profzl(apo_c,nii,resnog,rectog,0.0d0,slit)
c      write(*,*)resn, rect, ldec, grid
c      write(*,*)resnog, rectog, nhw, nii
      do j=ldec,1,-1
        call vdot(slit(j),ldec,unity,0,tot,2*nhw)
        call vmul(slit(j),ldec,1.0/tot,0,slit(j),ldec,2*nhw)
      end do
      slit(nii)=slit(nii)/tot

c===================================================================
c  Error estimation naively assumes spectral points are linearly independent.
c  CORRLD is an estimate of how dependent neighbouring points really are.
c  CORRLD = 1 means that points are truly linearly independent.
c  Variances must be scaled by CORRLD to ensure that when the same spectrum is
c  analyzed under different values of APO or INTERP, the same size errors result
      corrld=sqrt(rect**2+((1.+0.4*apo_c)*resn)**2)/gint
      sssss=sngl((startm/grid-kcp1+nsh-1+nhwmax-nhw)/rdec)

c==========================================================
c  Compute dSP/dASZA = dSP/dZ * dZ/dASZA
        if(zmin.lt.obalt) then
           tprange=sqrt((obalt-zmin)*(2*6378.0+obalt+zmin))
        else
           tprange=0.0
        endif
c        write(*,*)obalt,zmin,tprange,sza_ray,bend
        fovcf=0.0   !  FOV correction factor (0 disables FOV integration)
        zfov=fovcf*fovo*tprange  ! Empirical image compression
        dsplo=(splos(3)-splos(2))/(z(3)-z(2))
        do j=3,nlev-2
           dsphi=(splos(j+1)-splos(j))/(z(j+1)-z(j))
           dspdz(j)=0.5*zfov*(dsplo+dsphi)/2
           dsplo=dsphi
        end do
        dspdz(2)=0.0
        dspdz(nlev-1)=0.0
        dspdz(nlev)=0.0
c        write(37,*)obalt,zmin,sza_ray,zfov,tprange
c        do j=2,nlev
c           write(37,*)j,z(j),splos(j),dspdz(j)
c        end do
c========================================================
c  Compute SPXV
c  The first column of SPXV contains the non-target VACS
c  The next NTG columns of SPXV contain the target VACs
c  The NTG+2'nd column contains the Solar Transmittance Spectrum
c  The NTG+3'rd and NTG+4'rd columns are workspace.
c  SPXV does not change for a given observation geometry,
c  even though the absorber amounts are being iterated.
      jva=1
      jsp=1
      do jtg=0,ntg
         call vmov(zero,0,spxv(jsp),1,ncp)
         call vmov(zero,0,dspdzxv(jsp),1,ncp)
         do ilev=1,nlev
            call vsma(vac(jva),1,ckm2cm*splos(ilev),spxv(jsp),1,
     &      spxv(jsp),1,ncp)
            call vsma(vac(jva),1,ckm2cm*dspdz(ilev),dspdzxv(jsp),1,
     &      dspdzxv(jsp),1,ncp)
            jva=jva+ncp
         end do
c         if(jtg.eq.1) write(44,'(3f8.3,1p7e10.2)')zmin,sza_ray,bend,
c     &   (-spxv(jsp+jj),jj=0,ncp-1,ncp/6-1)
c         if(jtg.eq.1) write(45,'(3f8.3,1p7e10.2)')zmin,sza_ray,bend,
c     &   (-dspdzxv(jsp+jj),jj=0,ncp-1,ncp/6-1)
         jsp=jsp+ncp
      end do

      dopp=0.0d0
c   Add solar optical thickness spectrum to non-target ones in SPXV(JSP)
c   Use SPXV(JSP+NCP) as work space for Voigt functions.
      if( index(winfo,' so ') .gt. 0) then
         if    (runlab .eq. 'phg92258.600') then
            dopp=-0.04d-5
         elseif(runlab .eq. 'pin92258.600') then
            dopp=-0.22d-5
         elseif(runlab .eq. 'psl3.sun.1') then
            dopp=+2.68d-5
         elseif(runlab .eq. 'psl3.sun.2') then
            dopp=+2.42d-5
         elseif(runlab .eq. 'psl3.sun.3') then
            dopp=+2.37d-5
         elseif(runlab .eq. 'psl3.sun.4') then
            dopp=+2.3d-5
         elseif(runlab .eq. 'pat3.f09ss.sun') then
            dopp=-0.34d-5
         elseif(runlab .eq. 'pat3.f12ss.sun') then
            dopp=+0.23d-5
         elseif(runlab .eq. 'pat3.f03ss.sun') then
            dopp=-0.13d-5
        elseif(runlab .eq. 'pat3.f04ss.sun') then
            dopp=+0.89d-5
         elseif(runlab .eq. 'camy-peyret.solar_ir') then
            dopp=-0.06d-5
         elseif(runlab .eq. '901218R0.003') then
            dopp=-1.11d-6
         elseif(runlab .eq. '901218R0.006') then
            dopp=+0.72d-6
         elseif(runlab .eq. '810509R0.004') then
            dopp=+1.55d-6
         elseif(runlab .eq. '810509R0.005') then
            dopp=+2.75d-6
         elseif(runlab .eq. '790401R0.008') then
            dopp=+3.00d-6
         elseif(runlab .eq. '830619R0.003') then
            dopp=+3.20d-6
         elseif(runlab .eq. '830619R0.005') then
            dopp=+2.90d-6
         elseif(runlab(:9) .eq. 'phg06000.')then
              dopp=0.0d0
         elseif(runlab(:9) .eq. 'phg07000.')then
              dopp=0.0d0
         elseif(runlab(:9) .eq. 'phg06000.')then
              dopp=0.0d0
         elseif(runlab(:9) .eq. 'phg07000.')then
              dopp=0.0d0
         else
c compute Earth - Sun doppler stretch
            call zenaz(2,oblat,oblon,obalt,iyr,1,iset,
     &      zpdtim/24.0d0,ddum,ddum,eorv,ervc,
     &      ddum,ddum,ddum)
            dopp=(eorv+ervc)/3.d+08
         endif

         frac=fovo/9.2e-3  ! the sun is 9.2 mrad in diameter on average
         call solar_pseudo_trans_spec(lun_sts,solarll,
     &  fzero*(1.d0+dopp),grid*(1.d0+dopp),frac,spts,ncp)
      else
         call vmov(unity,0,spts,1,ncp)
      endif
      if(index(winfo,' sa_zoff ').gt.0) zoff=zoff+0.002

c===================================================================
c  Compute the vertical slant path distances
      if (nlev.le.2) then
        spver(1)=splos(1)
        spver(nlev)=splos(nlev)
      else
        call compute_vertical_paths(zmin,z,d,spver,nlev)
      endif  ! nlev.le.2
c===================================================================
c Compute vertical and LOS slant columns for the target gases
c Do in reverse order so that the concentration profile of the
c first target gas is retained in CP at the end.
      do jtg=ntg,1,-1
         jspeci=speci(jtg)
         call vmul(vmr(jspeci),nspexi,d,1,cp,1,nlev)
         call vdot(cp,1,spver,1,overcol(jtg),nlev)
         call vdot(cp,1,splos,1,oloscol(jtg),nlev)
         overcol(jtg)=overcol(jtg)*ckm2cm
         oloscol(jtg)=oloscol(jtg)*ckm2cm
      end do
c
      if(ntg.eq.0) then
c   compute total column amounts for air (vmr=1.000)
         call vdot(d,1,spver,1,overcol(1),nlev)
         call vdot(d,1,splos,1,oloscol(1),nlev)
      endif
c=====================================================================
c  Read the initial values of the parameters to be fitted and their estimated
c  a priori variances.
      open(lun_apx,file=ap_file,status='old')
      read(lun_apx,*)
      read(lun_apx,*) apx(n1),apu(n1)   ! Continuum Level
      read(lun_apx,*) apx(n2),apu(n2)   ! Continuum Tilt
      read(lun_apx,*) apx(n3),apu(n3)   ! Frequency Shift
      read(lun_apx,*) apx(n4),apu(n4)   ! Zero Offset
      read(lun_apx,*)
      read(lun_apx,*) apx(1),apu(1)
      read(lun_apx,*) apx(2),apu(2)
      close(lun_apx)
      call vmov(apx(2),0,apx(3),1,ntg-2) ! absorber amount
      apx(n4)=apx(n4)+sngl(zoff)
      call vmov(apu(2),0,apu(3),1,ntg-2)  ! vmr of non-target gases
      apu(n3)=apu(n3)*sngl(1.d0+rdec) ! shift   up from 0.5 4-DEC-98 gct
c==========================================================================
      call vmov(apx,1,cx,1,nfp) ! Initialize to A PRIORI each spectrum
      if(index(winfo,' cl ').gt.0) then
           cx(n1)=(obsrvd(1)+obsrvd(nmp))/2
           if(cx(n1).lt.1.0) cx(n1)=1.0
      else
           apu(n1)=1.
      endif
      if(debug) write(6,*)  'It   CL        CT    FS    ZOFF  RMS/CL'//
     &'  Vfact1  Vfact2  Vfact3  Vfact4  Vfact5  Vfact6'

      ifm=1
      if(index(winfo,'nfov=').gt.0) ifm=3
      if(ifm.eq.1) then   ! FOV center ray only
         call do_retrieval(obsrvd,nmp,apx,apu,slit,nii,
     &    ldec,rdec,spts,spxv,dspdzxv,vac,splos,nlev,ncp,ntg,snr,
     &    corrld,sssss,winfo,debug,mit,nit,calcul,rms,cx,ex,pd,ssnmp)
      elseif(ifm.eq.2) then  !  Fast approximate FOV integration
         call do_retrieval2(obsrvd,nmp,apx,apu,slit,nii,
     &  ldec,rdec,spts,spxv,dspdzxv,vac,splos,nlev,ncp,ntg,snr,
     &  corrld,sssss,winfo,debug,mit,nit,calcul,rms,cx,ex,slpd,pd,ssnmp)
      elseif(ifm.eq.3) then  ! Full numerical FOV integration (slow)
         solzen=sngl(asza+zenoff)
         roc=6378.
         fbar=(ifirst+ilast)*graw/2
         call do_retrieval3(obsrvd,nmp,apx,apu,slit,nii,
     &    z,t,p,solzen,fovo,roc,obalt,wavtkr,fbar,
     &    ldec,rdec,spts,spxv,dspdzxv,vac,splos,nlev,ncp,ntg,snr,
     &    corrld,sssss,winfo,debug,mit,nit,calcul,rms,cx,ex,pd,ssnmp)
      endif

c  Set error bars very small for air, otherwise it will
c  dominate the CO2/Air ratio uncertainties.
      if(index(winfo,' air ').gt.0) ex(1)=1.0e-08

c  Write .spt file for the first MSPT spectral fits
c       write(*,*)'sptpath=',sptpath, ispec,mspt
       if(ispec .le. mspt) then
          sptpath=sptfile(:lf-1)//runlab
          call write_spt(lun_spt,winfo,sptpath,
     &    obsrvd,calcul,cx,ex,startm+gint*(cx(n3)),
     &    dopp*freq_flag,gint,overcol, pars, asza+zenoff,obalt,zmin,
     &    abs(100*rms/cx(n1)), pd, ssnmp, nmp, nmpfp, ntg)
       endif

c  Solar_Gas_shift is the difference of the solar shift and the gas shift
c  expressed in terms of the observed spectral point spacing
c  Multiply by GINT to convert to cm-1.
c  Divide by frequency to normalize to a dimensionless stretch which
c  should then  be the same for all windows. Multiply by 10^6 for ppm.
       if(index(winfo,' so ').gt.0) then
         sgshift=1E6*2*gint/frqcen*
     &   solar_gas_shift(cx(n1),cx(n2),obsrvd,calcul,ssnmp,nmp)
c      write(*,*)cx(n1),cx(n2),cx(n3),obsrvd(1),calcul(1),pd(1+n1*nmpfp)
      else
         sgshift=0.0
       endif

c  Write the state vector and uncertainties to the .col file
      call write_col(lun_col,runlab,nit,rms,sgshift,gint,
     & zmin,oloscol,overcol,cx,ex,ntg)
c  And to the screen
      call write_col(6,runlab,nit,rms,sgshift,gint,
     & zmin,oloscol,overcol,cx,ex,ntg)

      if(debug .and. nit.eq.11) stop 'nit=11' 
c  Output PD's (weighting functions), for subsequent use
c  in deriving averaging kernels.
        if( index(winfo,' ak ') .gt. 0) then
           akpath=akfile(:lnbc(akfile))//runlab
           open(lun_ak,file=akpath,status='unknown')
           call fm(lun_ak,winfo,slit,nii,ldec,spts,spxv,dspdzxv,
     &     vac,splos,nlev,ncp,rdec,sssss,cx,ntg,calcul,pd,nmp)

c  Level 1 is the cell, so start ilev at 2.
           write(lun_ak,*)(splos(ilev)*cp(ilev),ilev=2,nlev)
           write(lun_ak,*) pout/1013.25
           write(lun_ak,*)(p(ilev),ilev=2,nlev)
           close(lun_ak)
        endif

       totit=totit+nit
       avgrms=avgrms+abs(rms)
       avgcl=avgcl+abs(cx(n1))
       toterr=toterr+1.0/ex(1)**2
       tottc=tottc+cx(1)/ex(1)**2
       tottc2=tottc2+((cx(1)-1)/ex(1))**2

      endif        !  (ncall.ge.1) then
      end do   !  ispec=1,mspectra     Main fitting loop over spectra
89    nspectra=ispec-1
      if(ncall.gt.0) then
         write(*,*)' Grid=',grid,'cm-1' 
         write(*,*)' Used ',float(nva+ncp)/mva,' of allocated memory'
         write(6,*)' Total number of iterations =',totit
         write(6,*)' Total number of spectra fitted  =',nspectra
         write(6,*)' Total number of mavblocks found =',mavfound
         write(6,*)' Average % RMS fit =',100*avgrms/avgcl
         write(*,*)' FOV correction factor=',fovcf
         avgtc=tottc/toterr
         rmstc=sqrt(abs(tottc2/toterr-(avgtc-1.)**2))
         write(6,*)' Average Totcon =',avgtc,' +- ',rmstc
      endif
      close(lun_rlg)
      close(lun_ray)
      close(lun_mav)
      ncall=ncall+1
      return
      end

      function riair(w,t,p,h)
c  Edlen's formula for the refractive index of air at wavenumber w cm-1
c  T is the air temperature in degrees Celsius
c  P is the air pressure in mbar
C  H is the relative humidity in %
      real*8 w,t,p,h,pp,delt,hh,riair
c      F1F(w)=0.378125+w*w*(2.1414E-11+w*w*1.793E-21)
c      F2F(w)=0.0624-w*w*6.8E-14
      if(w.lt.0.0) w=0.0
      PP=(p-.3175+5.E-4*(p-745.)+.13*(t-10.))*.7500646
      DELT=PP*(1.-PP*(1.57E-8*t-1.049E-6))/(1.+3.661E-3*t)
      HH=h*EXP(1.52334+t*(.07217-2.9549E-4*t))/(100.+.3661*t)
      riair=1.D0+1.E-6*(DELT*(0.378125+w*w*(2.1414E-11+w*w*1.793E-21))
     & -HH*(0.0624-w*w*6.8E-14))
      return
      END
