      subroutine average_with_mul_bias (ymiss,nrow,ncol,yobs,yerr,
     &ybar,eybar,scal,escal,cew,tew)

c  Performs a weighted average of a series of measurements
c  after removing any multiplicate bias.
c
c  Decomposes the Nrow x Ncol matrix of data values into the product
c  of a row average (YBAR) and a column-dependent scaling (SCAL).
c     yobs(i,j) ~ ybar(i) * scal(j)
c
c  For example, yobs(i,j) might represent a column abundance
c  retrieved from fitting the i'th spectrum in the j'th window.
c  It is reasonable to assume that:
c    - different windows may produce systematically different
c      columns due to spectroscopic line intensity errors.
c    - different spectra have slightly different column amounts
c      due to atmospheric drifts/changes
c  in which case the entire Nrow x Ncol matrix of column amounts
c  can be boiled down to a Ncol-vector of average column amounts
c  and a Nrow-vector of window-dependent scale factors.
c  This not only represents a large reduction in data to be
c  stored, from Nrow+Ncol to Nrow*Ncol, but the resulting vectors are far
c  more useful/meaningful.
c
c  Inputs:
c      ymiss            R*4  Missing value
c      nrow             I*4  1st dimension of YOBS (number of rows/spectra)
c      ncol             I*4  2nd dimension of YOBS (number of columns/windows)
c      yobs(nrow,ncol)  R*4  the data values
c      yerr(nrow,ncol)  R*4  the data value uncertainties
c
c  Outputs:
c      ybar(nrow)       R*4  average values of the row/spectrum
c      eybar(nrow)      R*4  average uncertainties for the row/spectrum
c      scal(ncol)       R*4  column/window scale factor
c      escal(ncol)      R*4  column/window scaling uncertainty
c      cew(ncol)        R*4  Scale Error Weight (SQRT(CHI2(jcol)/Nrow))
c      tew     R*4  Error Weight (SQRT(CHI2/Ncol/Nrow))
c
c  Minimizes:
c   CHI2 = Sumi Sumj [(yobs(i,j)-ybar(i)*scal(j))/yerr(i,j)]^2 + Sumj(scal(j)-1)^2
c
c  Solution is obtained by differentiating the above equation
c  with respect to each element of ybar(i) and scal(j) yielding
c   Sumj scal(j)*(yobs(i,j)-ybar(i)*scal(j))/yerr(i,j)^2 = 0  i=1,nrow
c   Sumi ybar(i)*(yobs(i,j)-ybar(i)*scal(j))/yerr(i,j)^2 + (scal(j)-1) = 0  j=1,ncol
c
c  which can be reorganized as
c    ybar(i) =   Sumj scal(j)*yobs(i,j)/yerr(i,j)^2 /   Sumj scal(j)^2/yerr(i,j)^2  i=1,nrow
c    scal(j) = 1+Sumi ybar(i)*yobs(i,j)/yerr(i,j)^2 / 1+Sumi ybar(i)^2/yerr(i,j)^2  j=1,ncol
c
c  Note that ybar(i) depends on scal(j) and vice versa. So that iteration is generally needed. 
c
c  The total error weight (TEW) is the square root of:
c    the CHI2 value divided by the total number of points.
c  If the error estimates (YERR) are consistent with the
c  scatter of the data values (YOBS), TEW should be ~1.
c  If TEW>1, the scatter of the data values exceeds the error bars.
c  CEW(JCOL) is the same thing, but for a particular column.
c    
      implicit none
      integer nrow,ncol,icol,jrow,jit,mit,nval_jcol,nval
      real*4 yobs(nrow,ncol),yerr(nrow,ncol),
     $ybar(nrow),eybar(nrow),scal(ncol),escal(ncol),
     $cew(ncol),tew,vnew,snew,res,ymiss

      real*8 tot_num,tot_denom,grr,gwt,twt,trr,wt,
     & eps
      parameter (mit=49,eps=1.0d-5)
c
      do icol=1,ncol
         scal(icol)=1.0d0
      end do
c
      do jrow=1,nrow
         ybar(jrow)=1.0d0
      end do
c
      do jit=1,mit   ! Iteration loop
c
c  Re-evaluate ybars (or column abundances)
      do jrow=1,nrow       ! loop over rows/spectra
         tot_num=0.d0
         tot_denom=0.d0
         do icol=1,ncol    ! loop over windows
            if(yerr(icol,jrow).ne.ymiss.and.yerr(icol,jrow).ne.0.0) then
               wt=scal(icol)/yerr(icol,jrow)
               tot_num=tot_num+wt*yobs(jrow,icol)/yerr(icol,jrow)
               tot_denom=tot_denom+wt**2
            endif
         end do
         if(tot_denom.eq.0.0d0) then
            eybar(jrow)=ymiss
            ybar(jrow)=ymiss
         else 
            eybar(jrow)=1.d0/dsqrt(tot_denom)
            ybar(jrow)=tot_num/tot_denom
         endif
      end do   !  jrow=1,nrow   end of ybar re-evaluation
c
c  Re-evaluate scal factors for each window
      do icol=1,ncol      ! Loop over windows
         tot_num=1.0d0    ! A priori estimate
         tot_denom=1.0d0  ! A priori estimate
         do jrow=1,nrow   ! Loop over rows/spectra
            if(yerr(icol,jrow).ne.ymiss.and.yerr(icol,jrow).ne.0.0) then
               wt=ybar(jrow)/yerr(icol,jrow)
               tot_num=tot_num+wt*yobs(jrow,icol)/yerr(jrow,icol)
               tot_denom=tot_denom+wt**2
            endif
         end do
         if(tot_denom.eq.0.0d0) then
            write(6,*)' No spectra for window'
            escal(icol)=0.0d0
            scal(icol)=1.0d0
         else
            escal(icol)=1.d0/dsqrt(tot_denom)
            scal(icol)=tot_num/tot_denom
         endif
      end do    ! icol=1,ncol    end of scale re-evaluation

      end do                           ! end of main iteration loop
      write(6,*)'Warning: average_with_mul_bias did not converge'
c
c  Error_weight is the factor by which the given standard errors (STERR)
c  must be scaled to be consistent with the observed scatter in the points.
c  In a perfect world it would be unity.
88    grr=0.0d0
      gwt=0.0d0
      do icol=1,ncol                   !calculate the rms fit
         trr=0.0d0
         twt=0.0d0
         do jrow=1,nrow
            if(yerr(icol,jrow).ne.ymiss.and.yerr(icol,jrow).ne.0.0) then
               twt=twt+1.0d0
               res=yobs(jrow,icol)-ybar(jrow)*scal(icol)
               trr=trr+( res/yerr(jrow,icol) )**2
            endif
         end do
         cew(icol)=dsqrt(trr/twt)   ! Scale Error Weight
         grr=grr+trr
         gwt=gwt+twt
      end do                         !end of rms calculation
      tew=dsqrt(grr/gwt)
      return
      end
